/* Configure Jacoco Coverage Reporting */

jacoco {
    toolVersion = "${jacocoToolVersion}"
}

tasks.register("codeCoverageReport", JacocoReport) {
    subprojects { subproject ->
        subproject.plugins.withType(JacocoPlugin).configureEach {
            subproject.tasks.matching({ t -> t.extensions.findByType(JacocoTaskExtension) }).configureEach { testTask ->
                sourceSets subproject.sourceSets.main
                executionData(testTask)
            }
            subproject.tasks.matching({ t -> t.extensions.findByType(JacocoTaskExtension) }).forEach {
                rootProject.tasks.codeCoverageReport.dependsOn(it)
            }
        }
    }

    reports {
        xml.enabled true
        html.enabled true
        csv.enabled false
    }
}
tasks.test.finalizedBy codeCoverageReport
tasks.check.dependsOn codeCoverageReport

/* Configure SonarQube Analysis */
sonarqube {
    properties {
        property "sonar.projectKey", "iorek"
        property "sonar.projectName", "iorek"
        property "sonar.exclusions", "**/build/generated/**,"
        property "sonar.coverage.exclusions", "**/src/test/**"
        property "sonar.coverage.jacoco.xmlReportPaths", ["${project.buildDir}/reports/jacoco/codeCoverageReport/codeCoverageReport.xml"]
        property "sonar.dependencyCheck.reportPath", "$project.buildDir/reports/dependency-check-report.xml"
        property "sonar.dependencyCheck.htmlReportPath", "$project.buildDir/reports/dependency-check-report.html"
        property "dc5.mutationAnalysis.pitest.sensor.reports.directory", "build/reports/pitest"
    }
}
rootProject.tasks["sonarqube"].mustRunAfter codeCoverageReport
rootProject.tasks["sonarqube"].dependsOn dependencyCheckAggregate
rootProject.tasks["sonarqube"].dependsOn subprojects.tasks["pitest"]
